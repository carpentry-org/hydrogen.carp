(relative-include "./hydrogenbuf.h")

(add-cflag (Dynamic.String.join [(Dynamic.String.directory (file))
                                 "/libhydrogen/hydrogen.c"
]))

(register-type HydroBuf)
(register-type HydroBufRaw)

(defmodule HydroBuf
  (register str (Fn [(Ref HydroBuf)] String))
  (register array (Fn [(Ref HydroBuf)] (Array Char)))
  (register length (Fn [(Ref HydroBuf)] Int))
  (register raw (Fn [(Ref HydroBuf)] HydroBufRaw))
)

(defmodule Hydro
  (register init (Fn [] ()) "hydro_init")
  (register allocate (Fn [Int] HydroBuf))
  (register buf (Fn [(Ref String)] HydroBuf))
  (register unbuf (Fn [(Ref HydroBuf)] String))

  (register erase- (Fn [HydroBufRaw Int] ()) "hydro_memzero")
  (defn erase [b] (erase- (HydroBuf.raw b) (HydroBuf.length b)))

  (register eq- (Fn [HydroBufRaw HydroBufRaw Int] Bool) "hydro_equal")
  (defn = [a b]
    (and
      (= (HydroBuf.length a) (HydroBuf.length b))
      (eq- (HydroBuf.raw a) (HydroBuf.raw b) (HydroBuf.length a))))

  (defn context [s]
    (do
      (assert (= (length s) 8))
      (cstr s)))
)

(Hydro.init)

(defmodule HydroRandom
  (register seed-bytes Int "hydro_random_SEEDBYTES")

  (register u32 (Fn [] Int) "hydro_random_u32")
  (register uniform (Fn [Int] Int) "hydro_random_uniform")
  (register buf- (Fn [HydroBufRaw Int] ()) "hydro_random_buf")
  (defn buf [n]
    (let-do [b (Hydro.allocate n)]
      (buf- (HydroBuf.raw &b) n)
      b))

  (register ratchet (Fn [] ()) "hydro_random_ratchet")
  (register reseed (Fn [] ()) "hydro_random_reseed")
  (register buf-deterministic- (Fn [HydroBufRaw Int HydroBufRaw] ())
            "hydro_random_buf_deterministic")
  (defn buf-deterministic [len bytes]
    (let-do [buf (Hydro.allocate len)]
      (buf-deterministic-
        (HydroBuf.raw &buf) (HydroBuf.length &buf) (HydroBuf.raw bytes))
      buf))
)

(defmodule HydroHash
  (register key-bytes Int "hydro_hash_KEYBYTES")
  (register bytes Int "hydro_hash_BYTES")
  (register bytes-max Int "hydro_hash_BYTES_MAX")
  (register bytes-min Int "hydro_hash_BYTES_MIN")
  (register context-bytes Int "hydro_hash_CONTEXTBYTES")

  (register-type HydroHashState)
  (register state (Fn [] HydroHashState))

  (register keygen- (Fn [HydroBufRaw] ()) "hydro_hash_keygen")
  (defn keygen []
    (let-do [k (Hydro.allocate key-bytes)]
      (keygen- (HydroBuf.raw &k))
      k))

  (register init- (Fn [(Ref HydroHashState) key bytes] Int)
            "hydro_hash_init")
  (defn init [s ctx k] (init- s ctx (HydroBuf.raw k)))

  (register update- (Fn [(Ref HydroHashState) HydroBufRaw Int] Int)
            "hydro_hash_update")
  (defn update [s buf] (update- s (HydroBuf.raw buf) (HydroBuf.length buf)))

  ; TODO: check error
  (register final- (Fn [(Ref HydroHashState) HydroBufRaw Int] Int)
            "hydro_hash_final")
  (defn final [s]
    (let-do [buf (Hydro.allocate bytes)]
      (ignore (final- s (HydroBuf.raw &buf) (HydroBuf.length &buf)))
      buf))

  (register gen-
            (Fn [HydroBufRaw Int HydroBufRaw Int (Ptr Char) HydroBufRaw] Int)
            "hydro_hash_hash")
  (defn gen [msg ctx key]
    (let-do [hash (Hydro.allocate bytes)]
      (ignore
        (gen-
          (HydroBuf.raw &hash) (HydroBuf.length &hash) (HydroBuf.raw msg)
          (HydroBuf.length msg) ctx (HydroBuf.raw key)))
      hash))
)

(defmodule HydroKDF
  (register context-bytes Int "hydro_kdf_CONTEXTBYTES")
  (register key-bytes Int "hydro_kdf_KEYBYTES")
  (register bytes-max Int "hydro_kdf_BYTES_MAX")
  (register bytes-max Int "hydro_kdf_BYTES_MIN")

  (register keygen- (Fn [HydroBufRaw] ()) "hydro_kdf_keygen")
  (defn keygen []
    (let-do [k (Hydro.allocate key-bytes)]
      (keygen- (HydroBuf.raw &k))
      k))

  (register derive-from-key-
            (Fn [HydroBufRaw Int Int (Ptr Char) HydroBufRaw] Int)
            "hydro_kdf_derive_from_key")
  ; TODO: check error
  (defn derive-from-key [subkey-len id ctx key]
    (let-do [sub (Hydro.allocate subkey-len)]
      (ignore (derive-from-key-
        (HydroBuf.raw &sub) (HydroBuf.length &sub) id ctx (HydroBuf.raw key)
      ))
      sub))
)

(defmodule HydroSecretBox
  (register context-bytes Int "hydro_secretbox_CONTEXTBYTES")
  (register key-bytes Int "hydro_secretbox_KEYBYTES")
  (register header-bytes Int "hydro_secretbox_HEADERBYTES")
  (register probe-bytes Int "hydro_secretbox_PROBEBYTES")

  (register keygen- (Fn [HydroBufRaw] ()) "hydro_secretbox_keygen")
  (defn keygen []
    (let-do [k (Hydro.allocate key-bytes)]
      (keygen- (HydroBuf.raw &k))
      k))

  ; TODO check error
  (register encrypt-
            (Fn [HydroBufRaw HydroBufRaw Int Int (Ptr Char) HydroBufRaw] Int)
            "hydro_secretbox_encrypt")
  (defn encrypt [m id ctx key]
    (let-do [c (Hydro.allocate (+ (HydroBuf.length m) header-bytes))]
      (ignore
        (encrypt-
          (HydroBuf.raw &c) (HydroBuf.raw m) (HydroBuf.length m) id
          ctx (HydroBuf.raw key)
        )
      )
      c))

  ; TODO propagate error
  (register decrypt-
            (Fn [HydroBufRaw HydroBufRaw Int Int (Ptr Char) HydroBufRaw] Int)
            "hydro_secretbox_decrypt")
  (defn decrypt [c id ctx key]
    (let-do [m (Hydro.allocate (- (HydroBuf.length c) header-bytes))]
      (ignore
        (decrypt-
          (HydroBuf.raw &m) (HydroBuf.raw c) (HydroBuf.length c) id
          ctx (HydroBuf.raw key)
        )
      )
      m))
)

(defmodule HydroSign
  (register bytes Int "hydro_sign_BYTES")
  (register context-bytes Int "hydro_sign_CONTEXTBYTES")
  (register public-key-bytes Int "hydro_sign_PUBLICKEYBYTES")
  (register secret-key-bytes Int "hydro_sign_SECRETKEYBYTES")
  (register seed-bytes Int "hydro_sign_SEEDBYTES")

  (register-type HydroSignKeyPair)
  (register keypair (Fn [] HydroSignKeyPair))
  (register pk (Fn [(Ref HydroSignKeyPair)] HydroBufRaw))
  (register sk (Fn [(Ref HydroSignKeyPair)] HydroBufRaw))


  (register keygen- (Fn [(Ref HydroSignKeyPair)] ()) "hydro_sign_keygen")
  (defn keygen []
    (let-do [k (keypair)]
      (keygen- &k)
      k))

  ; TODO: propagate error
  (register create-
            (Fn [HydroBufRaw HydroBufRaw Int (Ptr Char) HydroBufRaw] ())
            "hydro_sign_create")
  (defn create [msg ctx keypair]
    (let-do [signature (Hydro.allocate bytes)]
      (ignore
        (create-
          (HydroBuf.raw &signature) (HydroBuf.raw &msg) (HydroBuf.length &msg)
          ctx (sk &keypair)
        )
      )
      signature))

  (register verify-
            (Fn [HydroBufRaw HydroBufRaw Int (Ptr Char) HydroBufRaw] Int)
            "hydro_sign_create")
  (defn verify [signature msg ctx keypair]
    (= 0
      (verify-
        (HydroBuf.raw &signature) (HydroBuf.raw &msg) (HydroBuf.length &msg)
        ctx (pk &keypair)
      )
    )
  )

  (register-type HydroSignState)
  (register state (Fn [] HydroSignState))

  (register init (Fn [(Ref HydroSignState) ctx] Int)
            "hydro_sign_init")

  (register update- (Fn [(Ref HydroSignState) HydroBufRaw Int] Int)
            "hydro_sign_update")
  (defn update [s buf] (update- s (HydroBuf.raw buf) (HydroBuf.length buf)))

  ; TODO: check error
  (register final-create- (Fn [(Ref HydroSignState) HydroBufRaw HydroBufRaw] Int)
            "hydro_sign_final_create")
  (defn final-create [s keypair]
    (let-do [buf (Hydro.allocate bytes)]
      (ignore (final-create- s (HydroBuf.raw &buf) (sk keypair)))
      buf))

  ; TODO: check error
  (register final-verify- (Fn [(Ref HydroSignState) HydroBufRaw HydroBufRaw] Int)
            "hydro_sign_final_verify")
  (defn final-verify [s signature keypair]
    (= 0 (final-verify- s (HydroBuf.raw &signature) (pk keypair))))
)
