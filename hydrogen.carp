(relative-include "./hydrogenbuf.h")

(add-cflag (Dynamic.String.join [(Dynamic.String.directory (file))
                                 "/libhydrogen/hydrogen.c"
]))

(register-type HydroBuf)
(register-type HydroBufRaw)

(defmodule HydroBuf
  (register str (Fn [(Ref HydroBuf)] String))
  (defn prn [a] (HydroBuf.str a))
  (register array (Fn [(Ref HydroBuf)] (Array Char)))
  (register length (Fn [(Ref HydroBuf)] Int))
  (register raw (Fn [(Ref HydroBuf)] HydroBufRaw))
)
; needed for printing mapped in maybe
(defmodule HydroBufCopy
  (defn prn [a] (HydroBuf.str &a))
)

(defmodule Hydro
  (register init (Fn [] ()) "hydro_init")
  (register allocate (Fn [Int] HydroBuf))
  (register buf (Fn [(Ref String)] HydroBuf))
  (register unbuf (Fn [(Ref HydroBuf)] String))

  (register erase- (Fn [HydroBufRaw Int] ()) "hydro_memzero")
  (defn erase [b] (erase- (HydroBuf.raw b) (HydroBuf.length b)))

  (register eq- (Fn [HydroBufRaw HydroBufRaw Int] Bool) "hydro_equal")
  (defn = [a b]
    (and
      (= (HydroBuf.length a) (HydroBuf.length b))
      (eq- (HydroBuf.raw a) (HydroBuf.raw b) (HydroBuf.length a))))

  (defn context [s]
    (do
      (assert (= (length s) 8))
      (cstr s)))
)

(Hydro.init)

(defmodule HydroRandom
  (register seed-bytes Int "hydro_random_SEEDBYTES")

  (register u32 (Fn [] Int) "hydro_random_u32")
  (register uniform (Fn [Int] Int) "hydro_random_uniform")
  (register buf- (Fn [HydroBufRaw Int] ()) "hydro_random_buf")
  (defn buf [n]
    (let-do [b (Hydro.allocate n)]
      (buf- (HydroBuf.raw &b) n)
      b))

  (register ratchet (Fn [] ()) "hydro_random_ratchet")
  (register reseed (Fn [] ()) "hydro_random_reseed")
  (register buf-deterministic- (Fn [HydroBufRaw Int HydroBufRaw] ())
            "hydro_random_buf_deterministic")
  (defn buf-deterministic [len bytes]
    (let-do [buf (Hydro.allocate len)]
      (buf-deterministic-
        (HydroBuf.raw &buf) (HydroBuf.length &buf) (HydroBuf.raw bytes))
      buf))
)

(defmodule HydroHash
  (register key-bytes Int "hydro_hash_KEYBYTES")
  (register bytes Int "hydro_hash_BYTES")
  (register bytes-max Int "hydro_hash_BYTES_MAX")
  (register bytes-min Int "hydro_hash_BYTES_MIN")
  (register context-bytes Int "hydro_hash_CONTEXTBYTES")

  (register-type HydroHashState)
  (register state (Fn [] HydroHashState))

  (register keygen- (Fn [HydroBufRaw] ()) "hydro_hash_keygen")
  (defn keygen []
    (let-do [k (Hydro.allocate key-bytes)]
      (keygen- (HydroBuf.raw &k))
      k))

  (register init- (Fn [(Ref HydroHashState) key bytes] Int)
            "hydro_hash_init")
  (defn init [s ctx k] (init- s ctx (HydroBuf.raw k)))

  (register update- (Fn [(Ref HydroHashState) HydroBufRaw Int] Int)
            "hydro_hash_update")
  (defn update [s buf] (update- s (HydroBuf.raw buf) (HydroBuf.length buf)))

  (register final- (Fn [(Ref HydroHashState) HydroBufRaw Int] Int)
            "hydro_hash_final")
  (defn final [s]
    (let [buf (Hydro.allocate bytes)]
      (if (= (final- s (HydroBuf.raw &buf) (HydroBuf.length &buf)) 0)
        (Maybe.Just buf)
        (Maybe.Nothing))))

  (register gen-
            (Fn [HydroBufRaw Int HydroBufRaw Int (Ptr Char) HydroBufRaw] Int)
            "hydro_hash_hash")
  (defn gen [msg ctx key]
    (let [hash (Hydro.allocate bytes)]
      (if (= 0
        (gen-
          (HydroBuf.raw &hash) (HydroBuf.length &hash) (HydroBuf.raw msg)
          (HydroBuf.length msg) ctx (HydroBuf.raw key)))
        (Maybe.Just hash)
        (Maybe.Nothing))))
)

(defmodule HydroKDF
  (register context-bytes Int "hydro_kdf_CONTEXTBYTES")
  (register key-bytes Int "hydro_kdf_KEYBYTES")
  (register bytes-max Int "hydro_kdf_BYTES_MAX")
  (register bytes-max Int "hydro_kdf_BYTES_MIN")

  (register keygen- (Fn [HydroBufRaw] ()) "hydro_kdf_keygen")
  (defn keygen []
    (let-do [k (Hydro.allocate key-bytes)]
      (keygen- (HydroBuf.raw &k))
      k))

  (register derive-from-key-
            (Fn [HydroBufRaw Int Int (Ptr Char) HydroBufRaw] Int)
            "hydro_kdf_derive_from_key")
  (defn derive-from-key [subkey-len id ctx key]
    (let [sub (Hydro.allocate subkey-len)]
      (if (= 0 (derive-from-key-
        (HydroBuf.raw &sub) (HydroBuf.length &sub) id ctx (HydroBuf.raw key)
        ))
        (Maybe.Just sub)
        (Maybe.Nothing))))
)

(defmodule HydroSecretBox
  (register context-bytes Int "hydro_secretbox_CONTEXTBYTES")
  (register key-bytes Int "hydro_secretbox_KEYBYTES")
  (register header-bytes Int "hydro_secretbox_HEADERBYTES")
  (register probe-bytes Int "hydro_secretbox_PROBEBYTES")

  (register keygen- (Fn [HydroBufRaw] ()) "hydro_secretbox_keygen")
  (defn keygen []
    (let-do [k (Hydro.allocate key-bytes)]
      (keygen- (HydroBuf.raw &k))
      k))

  (register encrypt-
            (Fn [HydroBufRaw HydroBufRaw Int Int (Ptr Char) HydroBufRaw] Int)
            "hydro_secretbox_encrypt")
  (defn encrypt [m id ctx key]
    (let [c (Hydro.allocate (+ (HydroBuf.length m) header-bytes))]
      (if (= 0
        (encrypt-
          (HydroBuf.raw &c) (HydroBuf.raw m) (HydroBuf.length m) id
          ctx (HydroBuf.raw key)
        ))
        (Maybe.Just c)
        (Maybe.Nothing))))

  (register decrypt-
            (Fn [HydroBufRaw HydroBufRaw Int Int (Ptr Char) HydroBufRaw] Int)
            "hydro_secretbox_decrypt")
  (defn decrypt [c id ctx key]
    (let [m (Hydro.allocate (- (HydroBuf.length c) header-bytes))]
      (if (= 0
        (decrypt-
          (HydroBuf.raw &m) (HydroBuf.raw c) (HydroBuf.length c) id
          ctx (HydroBuf.raw key)
        ))
        (Maybe.Just m)
        (Maybe.Nothing))))
)

(defmodule HydroSign
  (register bytes Int "hydro_sign_BYTES")
  (register context-bytes Int "hydro_sign_CONTEXTBYTES")
  (register public-key-bytes Int "hydro_sign_PUBLICKEYBYTES")
  (register secret-key-bytes Int "hydro_sign_SECRETKEYBYTES")
  (register seed-bytes Int "hydro_sign_SEEDBYTES")

  (register-type HydroSignKeyPair)
  (register keypair (Fn [] HydroSignKeyPair))
  (register pk (Fn [(Ref HydroSignKeyPair)] HydroBufRaw))
  (register sk (Fn [(Ref HydroSignKeyPair)] HydroBufRaw))


  (register keygen- (Fn [(Ref HydroSignKeyPair)] ()) "hydro_sign_keygen")
  (defn keygen []
    (let-do [k (keypair)]
      (keygen- &k)
      k))

  (register create-
            (Fn [HydroBufRaw HydroBufRaw Int (Ptr Char) HydroBufRaw] Int)
            "hydro_sign_create")
  (defn create [msg ctx keypair]
    (let [signature (Hydro.allocate bytes)]
      (if (= 0
        (create-
          (HydroBuf.raw &signature) (HydroBuf.raw &msg) (HydroBuf.length &msg)
          ctx (sk &keypair)
        ))
        (Maybe.Just signature)
        (Maybe.Nothing))))

  (register verify-
            (Fn [HydroBufRaw HydroBufRaw Int (Ptr Char) HydroBufRaw] Int)
            "hydro_sign_create")
  (defn verify [signature msg ctx keypair]
    (= 0
      (verify-
        (HydroBuf.raw &signature) (HydroBuf.raw &msg) (HydroBuf.length &msg)
        ctx (pk &keypair)
      )
    )
  )

  (register-type HydroSignState)
  (register state (Fn [] HydroSignState))

  (register init (Fn [(Ref HydroSignState) ctx] Int)
            "hydro_sign_init")

  (register update- (Fn [(Ref HydroSignState) HydroBufRaw Int] Int)
            "hydro_sign_update")
  (defn update [s buf] (update- s (HydroBuf.raw buf) (HydroBuf.length buf)))

  (register final-create- (Fn [(Ref HydroSignState) HydroBufRaw HydroBufRaw] Int)
            "hydro_sign_final_create")
  (defn final-create [s keypair]
    (let-do [buf (Hydro.allocate bytes)]
      (if (= 0 (final-create- s (HydroBuf.raw &buf) (sk keypair)))
        (Maybe.Just buf)
        (Maybe.Nothing))))

  (register final-verify- (Fn [(Ref HydroSignState) HydroBufRaw HydroBufRaw] Int)
            "hydro_sign_final_verify")
  (defn final-verify [s signature keypair]
    (= 0 (final-verify- s (HydroBuf.raw &signature) (pk keypair))))
)

(defmodule HydroPWHash
  (register context-bytes Int "hydro_pwhash_CONTEXTBYTES")
  (register master-key-bytes Int "hydro_pwhash_MASTERKEYBYTES")
  (register stored-bytes Int "hydro_pwhash_STOREDBYTES")

  (def dflt-ops-limit 10000)
  (def dflt-mem-limit 0)
  (def dflt-threads 1)

  (register keygen- (Fn [HydroBufRaw] ()) "hydro_pwhash_keygen")
  (defn keygen []
    (let-do [k (Hydro.allocate master-key-bytes)]
      (keygen- (HydroBuf.raw &k))
      k))

  (register hash-deterministic-
            (Fn [HydroBufRaw Int (Ptr Char) Int (Ptr Char) HydrobBufRaw Int]
                Int)
            "hydro_pwhash_deterministic")
  (defn hash-deterministic [len pwd ctx master-key ops-limit]
    (let [h (Hydro.allocate len)]
      (if (= 0
        (hash-deterministic
          (HydroBuf.raw &h) len (cstr pwd) (length pwd) (HydroBuf.raw ctx)
          (HydroBuf.raw master-key) ops-limit
        ))
        (Maybe.Just h)
        (Maybe.Nothing))))

  (register create-
            (Fn [HydroBufRaw (Ptr Char) Int HydroBufRaw Int Int Int] Int)
            "hydro_pwhash_create")
  (defn create-with [pwd master-key ops-limit mem-limit threads]
    (let [h (Hydro.allocate stored-bytes)]
      (if (= 0
        (create-
          (HydroBuf.raw &h) (cstr pwd) (length pwd) (HydroBuf.raw master-key)
          ops-limit mem-limit threads
        ))
        (Maybe.Just h)
        (Maybe.Nothing))))
  (defn create [pwd master-key]
    (create-with pwd master-key dflt-ops-limit dflt-mem-limit dflt-threads))

  (register verify-
            (Fn [HydroBufRaw (Ptr Char) Int HydroBufRaw Int Int Int] Int)
            "hydro_pwhash_verify")
  (defn verify-with [hash pwd master-key ops-limit-max mem-limit-max threads-max]
    (= 0 (verify- (HydroBuf.raw &hash) (cstr pwd) (length pwd)
                  (HydroBuf.raw master-key) ops-limit-max mem-limit-max
                  threads-max)))
  (defn verify [hash pwd master-key]
    (verify-with hash pwd master-key dflt-ops-limit dflt-mem-limit dflt-threads))

  (register derive-static-key-
            (Fn [HydroBufRaw Int HydroBufRaw (Ptr Char) Int (Ptr Char)
                 HydroBufRaw Int Int Int]
                 Int)
            "hydro_pwhash_derive_static_key")
  (defn derive-static-key-with [static-key-len stored pwd ctx master-key
                                ops-limit-max mem-limit-max threads-max]
    (let [static-key (Hydro.allocate static-key-len)]
      (if (= 0 (derive-static-key-
        (HydroBuf.raw &static-key) static-key-len (HydroBuf.raw stored)
        (cstr pwd) (length pwd) ctx (HydroBuf.raw master-key) ops-limit-max
        mem-limit-max threads-max))
        (Maybe.Just static-key)
        (Maybe.Nothing))))
  (defn derive-static-key [static-key-len stored pwd ctx master-key]
    (derive-static-key-with
      static-key-len stored pwd ctx master-key dflt-ops-limit dflt-mem-limit
      dflt-threads))
)
